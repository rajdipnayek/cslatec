/* rc6j.f -- translated by f2c (version 12.02.01).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include <stdlib.h> /* For exit() */
#include <f2c.h>

/* Table of constant values */

static integer c__2 = 2;
static integer c__1 = 1;

/* DECK RC6J */
/* Subroutine */ int rc6j_(real *l2, real *l3, real *l4, real *l5, real *l6, 
	real *l1min, real *l1max, real *sixcof, integer *ndim, integer *ier)
{
    /* Initialized data */

    static real zero = 0.f;
    static real eps = .01f;
    static real one = 1.f;
    static real two = 2.f;
    static real three = 3.f;

    /* System generated locals */
    integer i__1;
    real r__1, r__2, r__3, r__4;

    /* Local variables */
    static integer i__, n;
    static real x, y, a1, a2, c1, c2, l1, x1, x2, x3, y1, y2, y3, dv, a1s, 
	    a2s, sum1, sum2, huge__;
    static integer nfin, nlim;
    static real tiny, c1old, sign1, sign2, denom;
    static integer index;
    static real cnorm, ratio;
    static integer lstep;
    extern doublereal r1mach_(integer *);
    static integer nfinp1, nfinp2, nfinp3, nstep2;
    static real oldfac, newfac, sumbac, srhuge, thresh;
    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 
	    integer *, ftnlen, ftnlen, ftnlen);
    static real sumfor, sumuni, srtiny;

/* ***BEGIN PROLOGUE  RC6J */
/* ***PURPOSE  Evaluate the 6j symbol h(L1) = {L1 L2 L3} */
/*                                           {L4 L5 L6} */
/*            for all allowed values of L1, the other parameters */
/*            being held fixed. */
/* ***LIBRARY   SLATEC */
/* ***CATEGORY  C19 */
/* ***TYPE      SINGLE PRECISION (RC6J-S, DRC6J-D) */
/* ***KEYWORDS  6J COEFFICIENTS, 6J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS, */
/*             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS, */
/*             WIGNER COEFFICIENTS */
/* ***AUTHOR  Gordon, R. G., Harvard University */
/*           Schulten, K., Max Planck Institute */
/* ***DESCRIPTION */

/* *Usage: */

/*        REAL L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF(NDIM) */
/*        INTEGER NDIM, IER */

/*        CALL RC6J(L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM, IER) */

/* *Arguments: */

/*     L2 :IN      Parameter in 6j symbol. */

/*     L3 :IN      Parameter in 6j symbol. */

/*     L4 :IN      Parameter in 6j symbol. */

/*     L5 :IN      Parameter in 6j symbol. */

/*     L6 :IN      Parameter in 6j symbol. */

/*     L1MIN :OUT  Smallest allowable L1 in 6j symbol. */

/*     L1MAX :OUT  Largest allowable L1 in 6j symbol. */

/*     SIXCOF :OUT Set of 6j coefficients generated by evaluating the */
/*                 6j symbol for all allowed values of L1.  SIXCOF(I) */
/*                 will contain h(L1MIN+I-1), I=1,2,...,L1MAX-L1MIN+1. */

/*     NDIM :IN    Declared length of SIXCOF in calling program. */

/*     IER :OUT    Error flag. */
/*                 IER=0 No errors. */
/*                 IER=1 L2+L3+L5+L6 or L4+L2+L6 not an integer. */
/*                 IER=2 L4, L2, L6 triangular condition not satisfied. */
/*                 IER=3 L4, L5, L3 triangular condition not satisfied. */
/*                 IER=4 L1MAX-L1MIN not an integer. */
/*                 IER=5 L1MAX less than L1MIN. */
/*                 IER=6 NDIM less than L1MAX-L1MIN+1. */

/* *Description: */

/*     The definition and properties of 6j symbols can be found, for */
/*  example, in Appendix C of Volume II of A. Messiah. Although the */
/*  parameters of the vector addition coefficients satisfy certain */
/*  conventional restrictions, the restriction that they be non-negative */
/*  integers or non-negative integers plus 1/2 is not imposed on input */
/*  to this subroutine. The restrictions imposed are */
/*       1. L2+L3+L5+L6 and L2+L4+L6 must be integers; */
/*       2. ABS(L2-L4).LE.L6.LE.L2+L4 must be satisfied; */
/*       3. ABS(L4-L5).LE.L3.LE.L4+L5 must be satisfied; */
/*       4. L1MAX-L1MIN must be a non-negative integer, where */
/*          L1MAX=MIN(L2+L3,L5+L6) and L1MIN=MAX(ABS(L2-L3),ABS(L5-L6)). */
/*  If all the conventional restrictions are satisfied, then these */
/*  restrictions are met. Conversely, if input to this subroutine meets */
/*  all of these restrictions and the conventional restriction stated */
/*  above, then all the conventional restrictions are satisfied. */

/*     The user should be cautious in using input parameters that do */
/*  not satisfy the conventional restrictions. For example, the */
/*  the subroutine produces values of */
/*       h(L1) = { L1 2/3  1 } */
/*               {2/3 2/3 2/3} */
/*  for L1=1/3 and 4/3 but none of the symmetry properties of the 6j */
/*  symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied. */

/*     The subroutine generates h(L1MIN), h(L1MIN+1), ..., h(L1MAX) */
/*  where L1MIN and L1MAX are defined above. The sequence h(L1) is */
/*  generated by a three-term recurrence algorithm with scaling to */
/*  control overflow. Both backward and forward recurrence are used to */
/*  maintain numerical stability. The two recurrence sequences are */
/*  matched at an interior point and are normalized from the unitary */
/*  property of 6j coefficients and Wigner's phase convention. */

/*    The algorithm is suited to applications in which large quantum */
/*  numbers arise, such as in molecular dynamics. */

/* ***REFERENCES  1. Messiah, Albert., Quantum Mechanics, Volume II, */
/*                  North-Holland Publishing Company, 1963. */
/*               2. Schulten, Klaus and Gordon, Roy G., Exact recursive */
/*                  evaluation of 3j and 6j coefficients for quantum- */
/*                  mechanical coupling of angular momenta, J Math */
/*                  Phys, v 16, no. 10, October 1975, pp. 1961-1970. */
/*               3. Schulten, Klaus and Gordon, Roy G., Semiclassical */
/*                  approximations to 3j and 6j coefficients for */
/*                  quantum-mechanical coupling of angular momenta, */
/*                  J Math Phys, v 16, no. 10, October 1975, */
/*                  pp. 1971-1988. */
/*               4. Schulten, Klaus and Gordon, Roy G., Recursive */
/*                  evaluation of 3j and 6j coefficients, Computer */
/*                  Phys Comm, v 11, 1976, pp. 269-278. */
/* ***ROUTINES CALLED  R1MACH, XERMSG */
/* ***REVISION HISTORY  (YYMMDD) */
/*   750101  DATE WRITTEN */
/*   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters */
/*           HUGE and TINY revised to depend on R1MACH. */
/*   891229  Prologue description rewritten; other prologue sections */
/*           revised; LMATCH (location of match point for recurrences) */
/*           removed from argument list; argument IER changed to serve */
/*           only as an error flag (previously, in cases without error, */
/*           it returned the number of scalings); number of error codes */
/*           increased to provide more precise error information; */
/*           program comments revised; SLATEC error handler calls */
/*           introduced to enable printing of error messages to meet */
/*           SLATEC standards. These changes were done by D. W. Lozier, */
/*           M. A. McClain and J. M. Smith of the National Institute */
/*           of Standards and Technology, formerly NBS. */
/*   910415  Mixed type expressions eliminated; variable C1 initialized; */
/*           description of SIXCOF expanded. These changes were done by */
/*           D. W. Lozier. */
/* ***END PROLOGUE  RC6J */



    /* Parameter adjustments */
    --sixcof;

    /* Function Body */

/* ***FIRST EXECUTABLE STATEMENT  RC6J */
    *ier = 0;
/*  HUGE is the square root of one twentieth of the largest floating */
/*  point number, approximately. */
    huge__ = sqrt(r1mach_(&c__2) / 20.f);
    srhuge = sqrt(huge__);
    tiny = 1.f / huge__;
    srtiny = 1.f / srhuge;

/*     LMATCH = ZERO */

/*  Check error conditions 1, 2, and 3. */
    r__1 = *l2 + *l3 + *l5 + *l6 + eps;
    r__2 = *l4 + *l2 + *l6 + eps;
    if (r_mod(&r__1, &one) >= eps + eps || r_mod(&r__2, &one) >= eps + eps) {
	*ier = 1;
	xermsg_("SLATEC", "RC6J", "L2+L3+L5+L6 or L4+L2+L6 not integer.", ier,
		 &c__1, (ftnlen)6, (ftnlen)4, (ftnlen)36);
	return 0;
    } else if (*l4 + *l2 - *l6 < zero || *l4 - *l2 + *l6 < zero || -(*l4) + *
	    l2 + *l6 < zero) {
	*ier = 2;
	xermsg_("SLATEC", "RC6J", "L4, L2, L6 triangular condition not satis"
		"fied.", ier, &c__1, (ftnlen)6, (ftnlen)4, (ftnlen)46);
	return 0;
    } else if (*l4 - *l5 + *l3 < zero || *l4 + *l5 - *l3 < zero || -(*l4) + *
	    l5 + *l3 < zero) {
	*ier = 3;
	xermsg_("SLATEC", "RC6J", "L4, L5, L3 triangular condition not satis"
		"fied.", ier, &c__1, (ftnlen)6, (ftnlen)4, (ftnlen)46);
	return 0;
    }

/*  Limits for L1 */

/* Computing MAX */
    r__3 = (r__1 = *l2 - *l3, dabs(r__1)), r__4 = (r__2 = *l5 - *l6, dabs(
	    r__2));
    *l1min = dmax(r__3,r__4);
/* Computing MIN */
    r__1 = *l2 + *l3, r__2 = *l5 + *l6;
    *l1max = dmin(r__1,r__2);

/*  Check error condition 4. */
    r__1 = *l1max - *l1min + eps;
    if (r_mod(&r__1, &one) >= eps + eps) {
	*ier = 4;
	xermsg_("SLATEC", "RC6J", "L1MAX-L1MIN not integer.", ier, &c__1, (
		ftnlen)6, (ftnlen)4, (ftnlen)24);
	return 0;
    }
    if (*l1min < *l1max - eps) {
	goto L20;
    }
    if (*l1min < *l1max + eps) {
	goto L10;
    }

/*  Check error condition 5. */
    *ier = 5;
    xermsg_("SLATEC", "RC6J", "L1MIN greater than L1MAX.", ier, &c__1, (
	    ftnlen)6, (ftnlen)4, (ftnlen)25);
    return 0;


/*  This is reached in case that L1 can take only one value */

L10:
/*     LSCALE = 0 */
    r__1 = -one;
    i__1 = (integer) (*l2 + *l3 + *l5 + *l6 + eps);
    sixcof[1] = pow_ri(&r__1, &i__1) / sqrt((*l1min + *l1min + one) * (*l4 + *
	    l4 + one));
    return 0;


/*  This is reached in case that L1 can take more than one value. */

L20:
/*     LSCALE = 0 */
    nfin = (integer) (*l1max - *l1min + one + eps);
    if (*ndim - nfin >= 0) {
	goto L23;
    } else {
	goto L21;
    }

/*  Check error condition 6. */
L21:
    *ier = 6;
    xermsg_("SLATEC", "RC6J", "Dimension of result array for 6j coefficients"
	    " too small.", ier, &c__1, (ftnlen)6, (ftnlen)4, (ftnlen)56);
    return 0;


/*  Start of forward recursion */

L23:
    l1 = *l1min;
    newfac = 0.f;
    c1 = 0.f;
    sixcof[1] = srtiny;
    sum1 = (l1 + l1 + one) * tiny;

    lstep = 1;
L30:
    ++lstep;
    l1 += one;

    oldfac = newfac;
    a1 = (l1 + *l2 + *l3 + one) * (l1 - *l2 + *l3) * (l1 + *l2 - *l3) * (-l1 
	    + *l2 + *l3 + one);
    a2 = (l1 + *l5 + *l6 + one) * (l1 - *l5 + *l6) * (l1 + *l5 - *l6) * (-l1 
	    + *l5 + *l6 + one);
    newfac = sqrt(a1 * a2);

    if (l1 < one + eps) {
	goto L40;
    }

    dv = two * (*l2 * (*l2 + one) * *l5 * (*l5 + one) + *l3 * (*l3 + one) * *
	    l6 * (*l6 + one) - l1 * (l1 - one) * *l4 * (*l4 + one)) - (*l2 * (
	    *l2 + one) + *l3 * (*l3 + one) - l1 * (l1 - one)) * (*l5 * (*l5 + 
	    one) + *l6 * (*l6 + one) - l1 * (l1 - one));

    denom = (l1 - one) * newfac;

    if (lstep - 2 <= 0) {
	goto L32;
    } else {
	goto L31;
    }

L31:
    c1old = dabs(c1);
L32:
    c1 = -(l1 + l1 - one) * dv / denom;
    goto L50;

/*  If L1 = 1, (L1 - 1) has to be factored out of DV, hence */

L40:
    c1 = -two * (*l2 * (*l2 + one) + *l5 * (*l5 + one) - *l4 * (*l4 + one)) / 
	    newfac;

L50:
    if (lstep > 2) {
	goto L60;
    }

/*  If L1 = L1MIN + 1, the third term in recursion equation vanishes */

    x = srtiny * c1;
    sixcof[2] = x;
    sum1 += tiny * (l1 + l1 + one) * c1 * c1;

    if (lstep == nfin) {
	goto L220;
    }
    goto L30;


L60:
    c2 = -l1 * oldfac / denom;

/*  Recursion to the next 6j coefficient X */

    x = c1 * sixcof[lstep - 1] + c2 * sixcof[lstep - 2];
    sixcof[lstep] = x;

    sumfor = sum1;
    sum1 += (l1 + l1 + one) * x * x;
    if (lstep == nfin) {
	goto L100;
    }

/*  See if last unnormalized 6j coefficient exceeds SRHUGE */

    if (dabs(x) < srhuge) {
	goto L80;
    }

/*  This is reached if last 6j coefficient larger than SRHUGE, */
/*  so that the recursion series SIXCOF(1), ... ,SIXCOF(LSTEP) */
/*  has to be rescaled to prevent overflow */

/*     LSCALE = LSCALE + 1 */
    i__1 = lstep;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if ((r__1 = sixcof[i__], dabs(r__1)) < srtiny) {
	    sixcof[i__] = zero;
	}
/* L70: */
	sixcof[i__] /= srhuge;
    }
    sum1 /= huge__;
    sumfor /= huge__;
    x /= srhuge;


/*  As long as the coefficient ABS(C1) is decreasing, the recursion */
/*  proceeds towards increasing 6j values and, hence, is numerically */
/*  stable.  Once an increase of ABS(C1) is detected, the recursion */
/*  direction is reversed. */

L80:
    if (c1old - dabs(c1) <= 0.f) {
	goto L100;
    } else {
	goto L30;
    }


/*  Keep three 6j coefficients around LMATCH for comparison later */
/*  with backward recursion. */

L100:
/*     LMATCH = L1 - 1 */
    x1 = x;
    x2 = sixcof[lstep - 1];
    x3 = sixcof[lstep - 2];



/*  Starting backward recursion from L1MAX taking NSTEP2 steps, so */
/*  that forward and backward recursion overlap at the three points */
/*  L1 = LMATCH+1, LMATCH, LMATCH-1. */

    nfinp1 = nfin + 1;
    nfinp2 = nfin + 2;
    nfinp3 = nfin + 3;
    nstep2 = nfin - lstep + 3;
    l1 = *l1max;

    sixcof[nfin] = srtiny;
    sum2 = (l1 + l1 + one) * tiny;


    l1 += two;
    lstep = 1;
L110:
    ++lstep;
    l1 -= one;

    oldfac = newfac;
    a1s = (l1 + *l2 + *l3) * (l1 - *l2 + *l3 - one) * (l1 + *l2 - *l3 - one) *
	     (-l1 + *l2 + *l3 + two);
    a2s = (l1 + *l5 + *l6) * (l1 - *l5 + *l6 - one) * (l1 + *l5 - *l6 - one) *
	     (-l1 + *l5 + *l6 + two);
    newfac = sqrt(a1s * a2s);

    dv = two * (*l2 * (*l2 + one) * *l5 * (*l5 + one) + *l3 * (*l3 + one) * *
	    l6 * (*l6 + one) - l1 * (l1 - one) * *l4 * (*l4 + one)) - (*l2 * (
	    *l2 + one) + *l3 * (*l3 + one) - l1 * (l1 - one)) * (*l5 * (*l5 + 
	    one) + *l6 * (*l6 + one) - l1 * (l1 - one));

    denom = l1 * newfac;
    c1 = -(l1 + l1 - one) * dv / denom;
    if (lstep > 2) {
	goto L120;
    }

/*  If L1 = L1MAX + 1 the third term in the recursion equation vanishes */

    y = srtiny * c1;
    sixcof[nfin - 1] = y;
    if (lstep == nstep2) {
	goto L200;
    }
    sumbac = sum2;
    sum2 += (l1 + l1 - three) * c1 * c1 * tiny;
    goto L110;


L120:
    c2 = -(l1 - one) * oldfac / denom;

/*  Recursion to the next 6j coefficient Y */

    y = c1 * sixcof[nfinp2 - lstep] + c2 * sixcof[nfinp3 - lstep];
    if (lstep == nstep2) {
	goto L200;
    }
    sixcof[nfinp1 - lstep] = y;
    sumbac = sum2;
    sum2 += (l1 + l1 - three) * y * y;

/*  See if last unnormalized 6j coefficient exceeds SRHUGE */

    if (dabs(y) < srhuge) {
	goto L110;
    }

/*  This is reached if last 6j coefficient larger than SRHUGE, */
/*  so that the recursion series SIXCOF(NFIN), ... ,SIXCOF(NFIN-LSTEP+1) */
/*  has to be rescaled to prevent overflow */

/*     LSCALE = LSCALE + 1 */
    i__1 = lstep;
    for (i__ = 1; i__ <= i__1; ++i__) {
	index = nfin - i__ + 1;
	if ((r__1 = sixcof[index], dabs(r__1)) < srtiny) {
	    sixcof[index] = zero;
	}
/* L130: */
	sixcof[index] /= srhuge;
    }
    sumbac /= huge__;
    sum2 /= huge__;

    goto L110;


/*  The forward recursion 6j coefficients X1, X2, X3 are to be matched */
/*  with the corresponding backward recursion values Y1, Y2, Y3. */

L200:
    y3 = y;
    y2 = sixcof[nfinp2 - lstep];
    y1 = sixcof[nfinp3 - lstep];


/*  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds */
/*  with minimal error. */

    ratio = (x1 * y1 + x2 * y2 + x3 * y3) / (x1 * x1 + x2 * x2 + x3 * x3);
    nlim = nfin - nstep2 + 1;

    if (dabs(ratio) < one) {
	goto L211;
    }

    i__1 = nlim;
    for (n = 1; n <= i__1; ++n) {
/* L210: */
	sixcof[n] = ratio * sixcof[n];
    }
    sumuni = ratio * ratio * sumfor + sumbac;
    goto L230;

L211:
    ++nlim;
    ratio = one / ratio;
    i__1 = nfin;
    for (n = nlim; n <= i__1; ++n) {
/* L212: */
	sixcof[n] = ratio * sixcof[n];
    }
    sumuni = sumfor + ratio * ratio * sumbac;
    goto L230;

L220:
    sumuni = sum1;


/*  Normalize 6j coefficients */

L230:
    cnorm = one / sqrt((*l4 + *l4 + one) * sumuni);

/*  Sign convention for last 6j coefficient determines overall phase */

    sign1 = r_sign(&one, &sixcof[nfin]);
    r__1 = -one;
    i__1 = (integer) (*l2 + *l3 + *l5 + *l6 + eps);
    sign2 = pow_ri(&r__1, &i__1);
    if (sign1 * sign2 <= 0.f) {
	goto L235;
    } else {
	goto L236;
    }
L235:
    cnorm = -cnorm;

L236:
    if (dabs(cnorm) < one) {
	goto L250;
    }

    i__1 = nfin;
    for (n = 1; n <= i__1; ++n) {
/* L240: */
	sixcof[n] = cnorm * sixcof[n];
    }
    return 0;

L250:
    thresh = tiny / dabs(cnorm);
    i__1 = nfin;
    for (n = 1; n <= i__1; ++n) {
	if ((r__1 = sixcof[n], dabs(r__1)) < thresh) {
	    sixcof[n] = zero;
	}
/* L251: */
	sixcof[n] = cnorm * sixcof[n];
    }

    return 0;
} /* rc6j_ */

