/* drc3jj.f -- translated by f2c (version 12.02.01).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include <stdlib.h> /* For exit() */
#include <f2c.h>

/* Table of constant values */

static integer c__2 = 2;
static integer c__1 = 1;

/* DECK DRC3JJ */
/* Subroutine */ int drc3jj_(doublereal *l2, doublereal *l3, doublereal *m2, 
	doublereal *m3, doublereal *l1min, doublereal *l1max, doublereal *
	thrcof, integer *ndim, integer *ier)
{
    /* Initialized data */

    static doublereal zero = 0.;
    static doublereal eps = .01;
    static doublereal one = 1.;
    static doublereal two = 2.;
    static doublereal three = 3.;

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    static integer i__, n;
    static doublereal x, y, a1, a2, c1, c2, l1, m1, x1, x2, x3, y1, y2, y3, 
	    dv, a1s, a2s, sum1, sum2, huge__;
    static integer nfin, nlim;
    static doublereal tiny, c1old, sign1, sign2, denom;
    static integer index;
    static doublereal cnorm, ratio;
    static integer lstep;
    extern doublereal d1mach_(integer *);
    static integer nfinp1, nfinp2, nfinp3, nstep2;
    static doublereal oldfac, newfac, sumbac, srhuge, thresh;
    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 
	    integer *, ftnlen, ftnlen, ftnlen);
    static doublereal sumfor, sumuni, srtiny;

/* ***BEGIN PROLOGUE  DRC3JJ */
/* ***PURPOSE  Evaluate the 3j symbol f(L1) = (  L1   L2 L3) */
/*                                           (-M2-M3 M2 M3) */
/*            for all allowed values of L1, the other parameters */
/*            being held fixed. */
/* ***LIBRARY   SLATEC */
/* ***CATEGORY  C19 */
/* ***TYPE      DOUBLE PRECISION (RC3JJ-S, DRC3JJ-D) */
/* ***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS, */
/*             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS, */
/*             WIGNER COEFFICIENTS */
/* ***AUTHOR  Gordon, R. G., Harvard University */
/*           Schulten, K., Max Planck Institute */
/* ***DESCRIPTION */

/* *Usage: */

/*        DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM) */
/*        INTEGER NDIM, IER */

/*        CALL DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM, IER) */

/* *Arguments: */

/*     L2 :IN      Parameter in 3j symbol. */

/*     L3 :IN      Parameter in 3j symbol. */

/*     M2 :IN      Parameter in 3j symbol. */

/*     M3 :IN      Parameter in 3j symbol. */

/*     L1MIN :OUT  Smallest allowable L1 in 3j symbol. */

/*     L1MAX :OUT  Largest allowable L1 in 3j symbol. */

/*     THRCOF :OUT Set of 3j coefficients generated by evaluating the */
/*                 3j symbol for all allowed values of L1.  THRCOF(I) */
/*                 will contain f(L1MIN+I-1), I=1,2,...,L1MAX+L1MIN+1. */

/*     NDIM :IN    Declared length of THRCOF in calling program. */

/*     IER :OUT    Error flag. */
/*                 IER=0 No errors. */
/*                 IER=1 Either L2.LT.ABS(M2) or L3.LT.ABS(M3). */
/*                 IER=2 Either L2+ABS(M2) or L3+ABS(M3) non-integer. */
/*                 IER=3 L1MAX-L1MIN not an integer. */
/*                 IER=4 L1MAX less than L1MIN. */
/*                 IER=5 NDIM less than L1MAX-L1MIN+1. */

/* *Description: */

/*     Although conventionally the parameters of the vector addition */
/*  coefficients satisfy certain restrictions, such as being integers */
/*  or integers plus 1/2, the restrictions imposed on input to this */
/*  subroutine are somewhat weaker. See, for example, Section 27.9 of */
/*  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah. */
/*  The restrictions imposed by this subroutine are */
/*       1. L2 .GE. ABS(M2) and L3 .GE. ABS(M3); */
/*       2. L2+ABS(M2) and L3+ABS(M3) must be integers; */
/*       3. L1MAX-L1MIN must be a non-negative integer, where */
/*          L1MAX=L2+L3 and L1MIN=MAX(ABS(L2-L3),ABS(M2+M3)). */
/*  If the conventional restrictions are satisfied, then these */
/*  restrictions are met. */

/*     The user should be cautious in using input parameters that do */
/*  not satisfy the conventional restrictions. For example, the */
/*  the subroutine produces values of */
/*       f(L1) = ( L1  2.5  5.8) */
/*               (-0.3 1.5 -1.2) */
/*  for L1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j */
/*  symbol, set forth on page 1056 of Messiah, is satisfied. */

/*     The subroutine generates f(L1MIN), f(L1MIN+1), ..., f(L1MAX) */
/*  where L1MIN and L1MAX are defined above. The sequence f(L1) is */
/*  generated by a three-term recurrence algorithm with scaling to */
/*  control overflow. Both backward and forward recurrence are used to */
/*  maintain numerical stability. The two recurrence sequences are */
/*  matched at an interior point and are normalized from the unitary */
/*  property of 3j coefficients and Wigner's phase convention. */

/*    The algorithm is suited to applications in which large quantum */
/*  numbers arise, such as in molecular dynamics. */

/* ***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook */
/*                  of Mathematical Functions with Formulas, Graphs */
/*                  and Mathematical Tables, NBS Applied Mathematics */
/*                  Series 55, June 1964 and subsequent printings. */
/*               2. Messiah, Albert., Quantum Mechanics, Volume II, */
/*                  North-Holland Publishing Company, 1963. */
/*               3. Schulten, Klaus and Gordon, Roy G., Exact recursive */
/*                  evaluation of 3j and 6j coefficients for quantum- */
/*                  mechanical coupling of angular momenta, J Math */
/*                  Phys, v 16, no. 10, October 1975, pp. 1961-1970. */
/*               4. Schulten, Klaus and Gordon, Roy G., Semiclassical */
/*                  approximations to 3j  and 6j coefficients for */
/*                  quantum-mechanical coupling of angular momenta, */
/*                  J Math Phys, v 16, no. 10, October 1975, */
/*                  pp. 1971-1988. */
/*               5. Schulten, Klaus and Gordon, Roy G., Recursive */
/*                  evaluation of 3j and 6j coefficients, Computer */
/*                  Phys Comm, v 11, 1976, pp. 269-278. */
/* ***ROUTINES CALLED  D1MACH, XERMSG */
/* ***REVISION HISTORY  (YYMMDD) */
/*   750101  DATE WRITTEN */
/*   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters */
/*           HUGE and TINY revised to depend on D1MACH. */
/*   891229  Prologue description rewritten; other prologue sections */
/*           revised; LMATCH (location of match point for recurrences) */
/*           removed from argument list; argument IER changed to serve */
/*           only as an error flag (previously, in cases without error, */
/*           it returned the number of scalings); number of error codes */
/*           increased to provide more precise error information; */
/*           program comments revised; SLATEC error handler calls */
/*           introduced to enable printing of error messages to meet */
/*           SLATEC standards. These changes were done by D. W. Lozier, */
/*           M. A. McClain and J. M. Smith of the National Institute */
/*           of Standards and Technology, formerly NBS. */
/*   910415  Mixed type expressions eliminated; variable C1 initialized; */
/*           description of THRCOF expanded. These changes were done by */
/*           D. W. Lozier. */
/* ***END PROLOGUE  DRC3JJ */



    /* Parameter adjustments */
    --thrcof;

    /* Function Body */

/* ***FIRST EXECUTABLE STATEMENT  DRC3JJ */
    *ier = 0;
/*  HUGE is the square root of one twentieth of the largest floating */
/*  point number, approximately. */
    huge__ = sqrt(d1mach_(&c__2) / 20.);
    srhuge = sqrt(huge__);
    tiny = 1. / huge__;
    srtiny = 1. / srhuge;

/*     LMATCH = ZERO */
    m1 = -(*m2) - *m3;

/*  Check error conditions 1 and 2. */
    if (*l2 - abs(*m2) + eps < zero || *l3 - abs(*m3) + eps < zero) {
	*ier = 1;
	xermsg_("SLATEC", "DRC3JJ", "L2-ABS(M2) or L3-ABS(M3) less than zero."
		, ier, &c__1, (ftnlen)6, (ftnlen)6, (ftnlen)40);
	return 0;
    } else /* if(complicated condition) */ {
	d__1 = *l2 + abs(*m2) + eps;
	d__2 = *l3 + abs(*m3) + eps;
	if (d_mod(&d__1, &one) >= eps + eps || d_mod(&d__2, &one) >= eps + 
		eps) {
	    *ier = 2;
	    xermsg_("SLATEC", "DRC3JJ", "L2+ABS(M2) or L3+ABS(M3) not intege"
		    "r.", ier, &c__1, (ftnlen)6, (ftnlen)6, (ftnlen)37);
	    return 0;
	}
    }



/*  Limits for L1 */

/* Computing MAX */
    d__2 = (d__1 = *l2 - *l3, abs(d__1)), d__3 = abs(m1);
    *l1min = max(d__2,d__3);
    *l1max = *l2 + *l3;

/*  Check error condition 3. */
    d__1 = *l1max - *l1min + eps;
    if (d_mod(&d__1, &one) >= eps + eps) {
	*ier = 3;
	xermsg_("SLATEC", "DRC3JJ", "L1MAX-L1MIN not integer.", ier, &c__1, (
		ftnlen)6, (ftnlen)6, (ftnlen)24);
	return 0;
    }
    if (*l1min < *l1max - eps) {
	goto L20;
    }
    if (*l1min < *l1max + eps) {
	goto L10;
    }

/*  Check error condition 4. */
    *ier = 4;
    xermsg_("SLATEC", "DRC3JJ", "L1MIN greater than L1MAX.", ier, &c__1, (
	    ftnlen)6, (ftnlen)6, (ftnlen)25);
    return 0;

/*  This is reached in case that L1 can take only one value, */
/*  i.e. L1MIN = L1MAX */

L10:
/*     LSCALE = 0 */
    d__2 = -one;
    i__1 = (integer) ((d__1 = *l2 + *m2 - *l3 + *m3, abs(d__1)) + eps);
    thrcof[1] = pow_di(&d__2, &i__1) / sqrt(*l1min + *l2 + *l3 + one);
    return 0;

/*  This is reached in case that L1 takes more than one value, */
/*  i.e. L1MIN < L1MAX. */

L20:
/*     LSCALE = 0 */
    nfin = (integer) (*l1max - *l1min + one + eps);
    if (*ndim - nfin >= 0) {
	goto L23;
    } else {
	goto L21;
    }

/*  Check error condition 5. */
L21:
    *ier = 5;
    xermsg_("SLATEC", "DRC3JJ", "Dimension of result array for 3j coefficien"
	    "ts too small.", ier, &c__1, (ftnlen)6, (ftnlen)6, (ftnlen)56);
    return 0;


/*  Starting forward recursion from L1MIN taking NSTEP1 steps */

L23:
    l1 = *l1min;
    newfac = 0.;
    c1 = 0.;
    thrcof[1] = srtiny;
    sum1 = (l1 + l1 + one) * tiny;


    lstep = 1;
L30:
    ++lstep;
    l1 += one;


    oldfac = newfac;
    a1 = (l1 + *l2 + *l3 + one) * (l1 - *l2 + *l3) * (l1 + *l2 - *l3) * (-l1 
	    + *l2 + *l3 + one);
    a2 = (l1 + m1) * (l1 - m1);
    newfac = sqrt(a1 * a2);
    if (l1 < one + eps) {
	goto L40;
    }


    dv = -(*l2) * (*l2 + one) * m1 + *l3 * (*l3 + one) * m1 + l1 * (l1 - one) 
	    * (*m3 - *m2);
    denom = (l1 - one) * newfac;

    if (lstep - 2 <= 0) {
	goto L32;
    } else {
	goto L31;
    }

L31:
    c1old = abs(c1);
L32:
    c1 = -(l1 + l1 - one) * dv / denom;
    goto L50;

/*  If L1 = 1, (L1-1) has to be factored out of DV, hence */

L40:
    c1 = -(l1 + l1 - one) * l1 * (*m3 - *m2) / newfac;

L50:
    if (lstep > 2) {
	goto L60;
    }


/*  If L1 = L1MIN + 1, the third term in the recursion equation vanishes, */
/*  hence */
    x = srtiny * c1;
    thrcof[2] = x;
    sum1 += tiny * (l1 + l1 + one) * c1 * c1;
    if (lstep == nfin) {
	goto L220;
    }
    goto L30;


L60:
    c2 = -l1 * oldfac / denom;

/*  Recursion to the next 3j coefficient X */

    x = c1 * thrcof[lstep - 1] + c2 * thrcof[lstep - 2];
    thrcof[lstep] = x;
    sumfor = sum1;
    sum1 += (l1 + l1 + one) * x * x;
    if (lstep == nfin) {
	goto L100;
    }

/*  See if last unnormalized 3j coefficient exceeds SRHUGE */

    if (abs(x) < srhuge) {
	goto L80;
    }

/*  This is reached if last 3j coefficient larger than SRHUGE, */
/*  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP) */
/*  has to be rescaled to prevent overflow */

/*     LSCALE = LSCALE + 1 */
    i__1 = lstep;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if ((d__1 = thrcof[i__], abs(d__1)) < srtiny) {
	    thrcof[i__] = zero;
	}
/* L70: */
	thrcof[i__] /= srhuge;
    }
    sum1 /= huge__;
    sumfor /= huge__;
    x /= srhuge;

/*  As long as ABS(C1) is decreasing, the recursion proceeds towards */
/*  increasing 3j values and, hence, is numerically stable.  Once */
/*  an increase of ABS(C1) is detected, the recursion direction is */
/*  reversed. */

L80:
    if (c1old - abs(c1) <= 0.) {
	goto L100;
    } else {
	goto L30;
    }


/*  Keep three 3j coefficients around LMATCH for comparison with */
/*  backward recursion. */

L100:
/*     LMATCH = L1 - 1 */
    x1 = x;
    x2 = thrcof[lstep - 1];
    x3 = thrcof[lstep - 2];
    nstep2 = nfin - lstep + 3;




/*  Starting backward recursion from L1MAX taking NSTEP2 steps, so */
/*  that forward and backward recursion overlap at three points */
/*  L1 = LMATCH+1, LMATCH, LMATCH-1. */

    nfinp1 = nfin + 1;
    nfinp2 = nfin + 2;
    nfinp3 = nfin + 3;
    l1 = *l1max;
    thrcof[nfin] = srtiny;
    sum2 = tiny * (l1 + l1 + one);

    l1 += two;
    lstep = 1;
L110:
    ++lstep;
    l1 -= one;

    oldfac = newfac;
    a1s = (l1 + *l2 + *l3) * (l1 - *l2 + *l3 - one) * (l1 + *l2 - *l3 - one) *
	     (-l1 + *l2 + *l3 + two);
    a2s = (l1 + m1 - one) * (l1 - m1 - one);
    newfac = sqrt(a1s * a2s);

    dv = -(*l2) * (*l2 + one) * m1 + *l3 * (*l3 + one) * m1 + l1 * (l1 - one) 
	    * (*m3 - *m2);

    denom = l1 * newfac;
    c1 = -(l1 + l1 - one) * dv / denom;
    if (lstep > 2) {
	goto L120;
    }

/*  If L1 = L1MAX + 1, the third term in the recursion formula vanishes */

    y = srtiny * c1;
    thrcof[nfin - 1] = y;
    sumbac = sum2;
    sum2 += tiny * (l1 + l1 - three) * c1 * c1;

    goto L110;


L120:
    c2 = -(l1 - one) * oldfac / denom;

/*  Recursion to the next 3j coefficient Y */

    y = c1 * thrcof[nfinp2 - lstep] + c2 * thrcof[nfinp3 - lstep];

    if (lstep == nstep2) {
	goto L200;
    }

    thrcof[nfinp1 - lstep] = y;
    sumbac = sum2;
    sum2 += (l1 + l1 - three) * y * y;

/*  See if last unnormalized 3j coefficient exceeds SRHUGE */

    if (abs(y) < srhuge) {
	goto L110;
    }

/*  This is reached if last 3j coefficient larger than SRHUGE, */
/*  so that the recursion series THRCOF(NFIN), ... ,THRCOF(NFIN-LSTEP+1) */
/*  has to be rescaled to prevent overflow */

/*     LSCALE = LSCALE + 1 */
    i__1 = lstep;
    for (i__ = 1; i__ <= i__1; ++i__) {
	index = nfin - i__ + 1;
	if ((d__1 = thrcof[index], abs(d__1)) < srtiny) {
	    thrcof[index] = zero;
	}
/* L130: */
	thrcof[index] /= srhuge;
    }
    sum2 /= huge__;
    sumbac /= huge__;


    goto L110;


/*  The forward recursion 3j coefficients X1, X2, X3 are to be matched */
/*  with the corresponding backward recursion values Y1, Y2, Y3. */

L200:
    y3 = y;
    y2 = thrcof[nfinp2 - lstep];
    y1 = thrcof[nfinp3 - lstep];


/*  Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds */
/*  with minimal error. */

    ratio = (x1 * y1 + x2 * y2 + x3 * y3) / (x1 * x1 + x2 * x2 + x3 * x3);
    nlim = nfin - nstep2 + 1;

    if (abs(ratio) < one) {
	goto L211;
    }

    i__1 = nlim;
    for (n = 1; n <= i__1; ++n) {
/* L210: */
	thrcof[n] = ratio * thrcof[n];
    }
    sumuni = ratio * ratio * sumfor + sumbac;
    goto L230;

L211:
    ++nlim;
    ratio = one / ratio;
    i__1 = nfin;
    for (n = nlim; n <= i__1; ++n) {
/* L212: */
	thrcof[n] = ratio * thrcof[n];
    }
    sumuni = sumfor + ratio * ratio * sumbac;
    goto L230;

L220:
    sumuni = sum1;


/*  Normalize 3j coefficients */

L230:
    cnorm = one / sqrt(sumuni);

/*  Sign convention for last 3j coefficient determines overall phase */

    sign1 = d_sign(&one, &thrcof[nfin]);
    d__2 = -one;
    i__1 = (integer) ((d__1 = *l2 + *m2 - *l3 + *m3, abs(d__1)) + eps);
    sign2 = pow_di(&d__2, &i__1);
    if (sign1 * sign2 <= 0.) {
	goto L235;
    } else {
	goto L236;
    }
L235:
    cnorm = -cnorm;

L236:
    if (abs(cnorm) < one) {
	goto L250;
    }

    i__1 = nfin;
    for (n = 1; n <= i__1; ++n) {
/* L240: */
	thrcof[n] = cnorm * thrcof[n];
    }
    return 0;

L250:
    thresh = tiny / abs(cnorm);
    i__1 = nfin;
    for (n = 1; n <= i__1; ++n) {
	if ((d__1 = thrcof[n], abs(d__1)) < thresh) {
	    thrcof[n] = zero;
	}
/* L251: */
	thrcof[n] = cnorm * thrcof[n];
    }

    return 0;
} /* drc3jj_ */

